## Общие правила

- **Менять можно только код в `src/main/java`**
- **Тесты менять нельзя**
- Если все тесты проходят — задание выполнено корректно
- Никакие дополнительные библиотеки использовать не нужно

Запуск:

```bash
mvn test
````

---

## Задание 1 — CounterWithSynchronized

### Суть

Есть обычный целочисленный счётчик.
Метод `increment()` вызывается одновременно из нескольких потоков.

### Проблема

Без синхронизации итоговое значение счётчика будет меньше ожидаемого.

### Требование

Сделать `increment()` потокобезопасным **с использованием `synchronized`**.

### Ожидаемый результат

* При запуске двух потоков по 1000 инкрементов итоговое значение равно `2000`
* Ни одного потерянного инкремента

---

## Задание 2 — CounterWithoutRace

### Суть

Счётчик инкрементируется **10 потоками одновременно**.

### Проблема

Возникает классический **race condition**.

### Требование

Устранить race condition любым корректным способом синхронизации.

### Ожидаемый результат

* После завершения всех потоков значение счётчика равно `10000`
* Результат стабилен при многократных запусках

---

## Задание 3 — VolatileFlag

### Суть

Есть рабочий поток, который крутится в цикле, пока не будет выставлен флаг остановки.

### Проблема

Без `volatile` поток может **никогда не увидеть изменение флага**.

### Требование

Обеспечить корректную остановку потока **через `volatile`**.

### Ожидаемый результат

* После вызова `stop()` поток гарантированно завершается
* `Thread.join()` не зависает

---

## Задание 4 — VisibilityProblem

### Суть

Один поток записывает значение, другой читает.

### Проблема

Без механизмов happens-before второй поток **может увидеть старое значение**.

### Требование

Гарантировать видимость изменений между потоками.

### Ожидаемый результат

* После завершения потока-записывателя `get()` возвращает актуальное значение
* Нет зависимости от случайного поведения JVM

---

## Задание 5 — DeadlockExample

### Суть

Есть два метода и два монитора (`lockA`, `lockB`).

### Проблема

Методы захватывают блокировки в разном порядке → возможен **deadlock**.

### Требование

Переписать код так, чтобы **deadlock был невозможен**.

### Ожидаемый результат

* Два потока, вызывающие `methodA()` и `methodB()`, всегда завершаются
* `join()` не зависает даже при повторных запусках

---

## Задание 6 — SynchronizedBlockOrdering

### Суть

Несколько потоков добавляют элементы в общий список.

### Проблема

Без синхронизации возможна неконсистентность состояния.

### Требование

Обеспечить корректную работу критической секции.

### Ожидаемый результат

* После выполнения всех потоков список содержит все добавленные элементы
* Размер списка всегда корректен

---

## Задание 7 — SafePublication

### Суть

Один поток инициализирует объект, другой его читает.

### Проблема

При небезопасной публикации другой поток может увидеть:

* `null`
* частично сконструированный объект

### Требование

Обеспечить **безопасную публикацию** объекта.

### Ожидаемый результат

* `getHolder()` всегда возвращает полностью сконструированный объект
* Все поля имеют корректные значения (`a = 1`, `b = 2`)

---

## Как понять, что всё сделано правильно

* Все тесты проходят локально (`mvn test`)
* Все тесты проходят в GitHub Actions
* Нет зависаний, флапающих тестов и нестабильных результатов
* Код использует базовые механизмы Java Concurrency (`synchronized`, `volatile`, порядок захвата мониторов)

---

## Чему этот проект учит

* Почему `volatile` — это **про видимость**, а не атомарность
* Почему `synchronized` — это не только mutual exclusion, но и happens-before
* Как возникают deadlock-и и как их проектно устранять
* Почему «работает у меня» — не критерий корректности многопоточного кода
